1. Database Browsing (The Data Grid)
For populating a high-performance data grid, you must use the query endpoint with settings that minimize overhead.
• Primary Endpoint: GET or POST to /db/query.
• Optimal Parameters:
    ◦ associative: This is critical for UI development; it returns rows as a map (key-value pairs) per row, which Quasar's q-table can ingest directly.
    ◦ level=none: This provides the absolute fastest query response because the node simply reads its local SQLite database without checking for leadership or cluster contact.
    ◦ blob_array: If your tables contain binary data, this parameter returns BLOBs as an array of byte values instead of base64 strings, making it easier for JavaScript to process.
• Axios Example:
2. Interactive Data Editing (Inline Cell Updates)
When a user edits a cell in your grid, you need a write operation that ensures the change is replicated across the cluster.
• Primary Endpoint: POST to /db/execute.
• Optimal Parameters:
    ◦ Parameterized Statements: To prevent SQL Injection attacks, always send the SQL statement and values as distinct elements in a JSON array.
    ◦ raft_index: Adding this parameter returns the Raft log index, allowing your UI to track exactly when the write was persisted to the cluster.
• Performance Strategy: Performance is "much, much better" if you batch multiple edits into a single request using the transaction parameter. If a user edits five rows and hits "Save All," wrap them in one transaction.
• Axios Example (Single Edit):
3. Raw Query Execution (The Console)
For a developer console where any SQL can be typed, the Unified Endpoint is the most robust choice.
• Primary Endpoint: POST to /db/request.
• Behavior: This endpoint uses the sqlite3_stmt_readonly() function to automatically detect if the user's input is a read (SELECT) or a write (INSERT/UPDATE).
• Optimal Parameters:
    ◦ db_timeout: Set a limit (e.g., 5s) to ensure long-running or accidental infinite-loop queries are interrupted.
    ◦ associative: Even for raw queries, this ensures the UI can easily map the results to a data table.
4. High-Throughput Import/Export
For bulk data movement, you must bypass individual row processing.
• Bulk Import:
    ◦ Use POST /db/execute?transaction. A bulk operation is contained within a single Raft log entry, ensuring it is not interleaved with other requests and significantly increasing throughput.
    ◦ queue: If immediate durability isn't required, use the Queued Writes API. This allows rqlite to batch writes asynchronously, providing the highest possible write performance by merging multiple requests into a single bulk insert.
• Bulk Export:
    ◦ Use GET /db/query?associative&level=none. This allows you to dump the database state from any node without taxing the cluster Leader.
5. API Design Summary Table
UI Feature
Endpoint
Method
Key Parameters
Grid Browsing
/db/query
GET/POST
associative, level=none, blob_array
Inline Editing
/db/execute
POST
transaction, raft_index, JSON-formatted
Raw Console
/db/request
POST
associative, db_timeout, timings
Bulk Import
/db/execute
POST
transaction or queue
Bulk Export
/db/query
GET
associative, level=none
Schema Info
/db/query
GET
q=PRAGMA table_info(name)
6. Critical Implementation Best Practices
• Error Handling: You must check for an error key in the JSON response even if Axios receives an HTTP 200 OK, as database-level errors (like syntax mistakes) are returned within the payload.
• Leader Routing: For maximum performance, add redirect to your write requests. If you hit a Follower, it will return a 301 Moved Permanently with the Leader's address, allowing your UI to update its base URL and talk directly to the Leader.
• Format: Always use the JSON request format for production code, as it is more structured and minimizes errors compared to plain text.
• Pragma Constraints: While you can use PRAGMA to get schema info, never attempt to change journal_mode, wal_checkpoint, or synchronous settings, as rqlite will return an error to protect cluster integrity.
