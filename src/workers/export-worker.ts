/**
 * Web Worker for formatting export data (CSV/SQL) off the main thread
 * Receives batches of rows and formats them into the target format
 */

export interface ExportWorkerMessage {
  type: 'init-csv' | 'init-sql' | 'batch' | 'finish' | 'cancel';
  headers?: string[];
  tableName?: string;
  rows?: Record<string, unknown>[];
  totalRows?: number;
}

export interface ExportWorkerResponse {
  type: 'chunk' | 'complete' | 'error' | 'progress';
  chunk?: string;
  totalFormatted?: number;
  error?: string;
}

let cancelled = false;
let headers: string[] = [];
let tableName = '';
let format: 'csv' | 'sql' = 'csv';
let totalFormatted = 0;

self.onmessage = (e: MessageEvent<ExportWorkerMessage>) => {
  const msg = e.data;

  switch (msg.type) {
    case 'cancel':
      cancelled = true;
      break;

    case 'init-csv':
      cancelled = false;
      format = 'csv';
      headers = msg.headers || [];
      tableName = msg.tableName || 'export';
      totalFormatted = 0;
      // Send CSV header row
      postResponse({ type: 'chunk', chunk: headers.join(',') + '\n' });
      break;

    case 'init-sql': {
      cancelled = false;
      format = 'sql';
      headers = msg.headers || [];
      tableName = msg.tableName || 'export';
      totalFormatted = 0;
      // Send SQL header comments
      const header = [
        `-- Export of table "${tableName}"`,
        `-- Generated by rqLui on ${new Date().toISOString()}`,
        `-- Total rows: ${msg.totalRows || 'unknown'}`,
        '',
      ].join('\n');
      postResponse({ type: 'chunk', chunk: header });
      break;
    }

    case 'batch':
      if (cancelled || !msg.rows) break;
      
      if (format === 'csv') {
        formatCSVBatch(msg.rows);
      } else {
        formatSQLBatch(msg.rows);
      }
      break;

    case 'finish':
      if (!cancelled) {
        postResponse({ type: 'complete', totalFormatted });
      }
      break;
  }
};

function postResponse(response: ExportWorkerResponse) {
  self.postMessage(response);
}

function formatCSVBatch(rows: Record<string, unknown>[]) {
  const lines: string[] = [];

  for (const row of rows) {
    if (cancelled) break;

    const csvRow = headers.map((h) => {
      const val = row[h];
      if (val === null || val === undefined) return '';
      if (typeof val === 'object') return `"${JSON.stringify(val).replace(/"/g, '""')}"`;
      const str = typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean'
        ? String(val)
        : JSON.stringify(val);
      return str.includes(',') || str.includes('"') || str.includes('\n')
        ? `"${str.replace(/"/g, '""')}"`
        : str;
    }).join(',');
    
    lines.push(csvRow);
    totalFormatted++;
  }

  if (lines.length > 0) {
    postResponse({ 
      type: 'chunk', 
      chunk: lines.join('\n') + '\n',
      totalFormatted 
    });
  }

  postResponse({ type: 'progress', totalFormatted });
}

function formatSQLBatch(rows: Record<string, unknown>[]) {
  const statements: string[] = [];

  for (const row of rows) {
    if (cancelled) break;

    const values = headers.map((col) => {
      const val = row[col];
      if (val === null || val === undefined) return 'NULL';
      if (typeof val === 'number') return String(val);
      if (typeof val === 'boolean') return val ? '1' : '0';
      if (typeof val === 'object') return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
      const strVal = typeof val === 'string' ? val : JSON.stringify(val);
      return `'${strVal.replace(/'/g, "''")}'`;
    });

    statements.push(
      `INSERT INTO "${tableName}" (${headers.map((c) => `"${c}"`).join(', ')}) VALUES (${values.join(', ')});`
    );
    totalFormatted++;
  }

  if (statements.length > 0) {
    postResponse({ 
      type: 'chunk', 
      chunk: statements.join('\n') + '\n',
      totalFormatted 
    });
  }

  postResponse({ type: 'progress', totalFormatted });
}
